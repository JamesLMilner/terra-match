{"version":3,"file":"terra-match.modern.js","sources":["../src/terra-match.ts"],"sourcesContent":["import { LineString, Polygon, Position } from 'geojson';\nimport * as turf from '@turf/turf';\n\ntype DistanceMetric = (p1: Position, p2: Position) => number\n\nfunction haversineDistance(p1: Position, p2: Position): number {\n    const [lat1, lon1] = p1;\n    const [lat2, lon2] = p2;\n    const R = 6371e3; // metres\n    const φ1 = lat1 * Math.PI / 180; // φ, λ in radians\n    const φ2 = lat2 * Math.PI / 180;\n    const Δφ = (lat2 - lat1) * Math.PI / 180;\n    const Δλ = (lon2 - lon1) * Math.PI / 180;\n\n    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +\n        Math.cos(φ1) * Math.cos(φ2) *\n        Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return R * c; // in metres\n}\n\nexport function terraMatch(P: Polygon, Q: Polygon, options: {\n    distanceMetric?: DistanceMetric,\n    checkPermutations?: boolean,\n    cleanRedundant?: boolean,\n    decay?: 'linear' | 'exponential'\n} = {}): number {\n    const {\n        distanceMetric = haversineDistance,\n        checkPermutations = true,\n        cleanRedundant = true,\n        decay = 'exponential'\n    } = options\n\n    const bbox = turf.bbox({\n        type: \"FeatureCollection\", features: [\n            { type: \"Feature\", geometry: P, properties: {} },\n            { type: \"Feature\", geometry: Q, properties: {} }\n        ]\n    });\n\n    if (cleanRedundant) {\n        turf.cleanCoords(Q, { mutate: true });\n    }\n\n    const QPermutations = checkPermutations ? generateGeometryCoordinatePermutations(Q) : [Q];\n    const QWithPermutations = [Q, ...QPermutations]\n\n    let smallestDistance = Infinity;\n\n    while (QWithPermutations.length > 0) {\n        const permutedQ: Polygon = QWithPermutations.pop() as Polygon;\n        const distance = frechetDistance(P, permutedQ, { distanceMetric });\n\n        if (distance < smallestDistance) {\n            smallestDistance = distance;\n        }\n    }\n\n\n    const bboxDistance = distanceMetric([bbox[0], bbox[1]], [bbox[2], bbox[3]]);\n\n    return decay === 'linear' ? linearDecayFunction(smallestDistance, bboxDistance) : exponentialDecayFunction(smallestDistance, bboxDistance);\n}\n\n/**\n * Compute discrete Fréchet distance between two polygon Position sequences\n */\nexport function frechetDistance(\n    polygon1: Polygon | LineString,\n    polygon2: Polygon | LineString,\n    options: { distanceMetric: DistanceMetric } = { distanceMetric: haversineDistance }\n): number {\n    const { distanceMetric } = options;\n\n    const coordinatesOne = polygon1.type === 'Polygon' ? polygon1.coordinates[0] : polygon1.coordinates\n    const coordinatesTwo = polygon2.type === 'Polygon' ? polygon2.coordinates[0] : polygon2.coordinates\n\n    const numVerticesPolygon1 = coordinatesOne.length;\n    const numVerticesPolygon2 = coordinatesTwo.length;\n\n    const memoizationTable: number[][] = Array.from({ length: numVerticesPolygon1 }, () => Array(numVerticesPolygon2).fill(-1));\n\n    function calculateFrechetDistance(indexOne: number, indexTwo: number): number {\n        // Base cases\n        if (memoizationTable[indexOne][indexTwo] !== -1) {\n            return memoizationTable[indexOne][indexTwo];\n        }\n\n        if (indexOne === 0 && indexTwo === 0) {\n            memoizationTable[indexOne][indexTwo] = distanceMetric(\n                coordinatesOne[0],\n                coordinatesTwo[0]\n            );\n        } else if (indexOne > 0 && indexTwo === 0) {\n            memoizationTable[indexOne][indexTwo] = Math.max(\n                calculateFrechetDistance(indexOne - 1, 0),\n                distanceMetric(coordinatesOne[indexOne], coordinatesTwo[0])\n            );\n        } else if (indexOne === 0 && indexTwo > 0) {\n            memoizationTable[indexOne][indexTwo] = Math.max(\n                calculateFrechetDistance(0, indexTwo - 1),\n                distanceMetric(coordinatesOne[0], coordinatesTwo[indexTwo])\n            );\n        } else if (indexOne > 0 && indexTwo > 0) {\n            memoizationTable[indexOne][indexTwo] = Math.max(\n                Math.min(\n                    calculateFrechetDistance(indexOne - 1, indexTwo),\n                    calculateFrechetDistance(indexOne - 1, indexTwo - 1),\n                    calculateFrechetDistance(indexOne, indexTwo - 1)\n                ),\n                distanceMetric(coordinatesOne[indexOne], coordinatesTwo[indexTwo])\n            );\n        } else {\n            memoizationTable[indexOne][indexTwo] = Infinity;\n        }\n        return memoizationTable[indexOne][indexTwo];\n    }\n\n    const frechetDistanceValue = calculateFrechetDistance(numVerticesPolygon1 - 1, numVerticesPolygon2 - 1);\n\n    return frechetDistanceValue;\n}\n\nexport function exponentialDecayFunction(distance: number, maxDistance: number): number {\n    const alpha = -Math.log(0.005) / maxDistance;\n\n    // Exponential decay function to get similarity score\n    return Math.exp(-alpha * distance);\n}\n\nexport function linearDecayFunction(distance: number, maxDistance: number): number {\n    // Ensure distance is capped between 0 and maxDistance\n    const cappedDistance = Math.min(distance, maxDistance);\n\n    // Linear decay from 1 to 0 over the range [0, maxDistance]\n    return 1 - cappedDistance / maxDistance;\n}\n\nexport function generateGeometryCoordinatePermutations<T extends Polygon | LineString>(geometry: T): T[] {\n    // Check if the polygon has coordinates\n    if (!geometry.coordinates || geometry.coordinates.length === 0) {\n        return [];\n    }\n\n    const coordinates = geometry.type === 'Polygon' ? geometry.coordinates[0].slice(0, -1) : geometry.coordinates.slice(0) // Get the first ring of the polygon\n\n    const n = coordinates.length;\n\n    // Array to hold all permutations\n    const permutations: T[] = [];\n\n    // Generate all permutations by rotating the coordinates\n    for (let i = 0; i < n; i++) {\n\n        const permutedCoordinates = [...coordinates.slice(i), ...coordinates.slice(0, i)];\n\n        if (geometry.type === 'Polygon') {\n            permutedCoordinates.push(permutedCoordinates[0])\n        }\n\n        if (geometry.type === 'LineString' || i !== 0) {\n            // Create a new permutation starting from the i-th vertex\n            permutations.push({\n                type: geometry.type,\n                coordinates: geometry.type === 'Polygon' ? [permutedCoordinates] : permutedCoordinates // Wrap in an array for GeoJSON format\n            } as T);\n        }\n\n        // Create and add the reverse permutation\n        const reversedCoordinates = [...permutedCoordinates].reverse();\n        permutations.push({\n            type: geometry.type,\n            coordinates: geometry.type === 'Polygon' ? [reversedCoordinates] : reversedCoordinates // Wrap in an array for GeoJSON format\n        } as T);\n\n    }\n\n    return permutations;\n}"],"names":["haversineDistance","p1","p2","lat1","lon1","lat2","lon2","φ1","Math","PI","φ2","Δφ","Δλ","a","sin","cos","atan2","sqrt","terraMatch","P","Q","options","distanceMetric","checkPermutations","cleanRedundant","decay","bbox","turf","type","features","geometry","properties","cleanCoords","mutate","QWithPermutations","generateGeometryCoordinatePermutations","smallestDistance","Infinity","length","distance","frechetDistance","pop","bboxDistance","linearDecayFunction","exponentialDecayFunction","polygon1","polygon2","coordinatesOne","coordinates","coordinatesTwo","numVerticesPolygon1","numVerticesPolygon2","memoizationTable","Array","from","fill","calculateFrechetDistance","indexOne","indexTwo","max","min","maxDistance","alpha","log","exp","slice","n","permutations","i","permutedCoordinates","push","reversedCoordinates","reverse"],"mappings":"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"}