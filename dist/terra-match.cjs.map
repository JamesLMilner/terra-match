{"version":3,"file":"terra-match.cjs","sources":["../src/terra-match.ts"],"sourcesContent":["import { LineString, Polygon, Position } from 'geojson';\nimport * as turf from '@turf/turf';\n\ntype DistanceMetric = (p1: Position, p2: Position) => number\n\nfunction haversineDistance(p1: Position, p2: Position): number {\n    const [lat1, lon1] = p1;\n    const [lat2, lon2] = p2;\n    const R = 6371e3; // metres\n    const φ1 = lat1 * Math.PI / 180; // φ, λ in radians\n    const φ2 = lat2 * Math.PI / 180;\n    const Δφ = (lat2 - lat1) * Math.PI / 180;\n    const Δλ = (lon2 - lon1) * Math.PI / 180;\n\n    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +\n        Math.cos(φ1) * Math.cos(φ2) *\n        Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return R * c; // in metres\n}\n\nexport function terraMatch(P: Polygon, Q: Polygon, options: {\n    distanceMetric?: DistanceMetric,\n    checkPermutations?: boolean,\n    cleanRedundant?: boolean,\n    decay?: 'linear' | 'exponential'\n} = {}): number {\n    const {\n        distanceMetric = haversineDistance,\n        checkPermutations = true,\n        cleanRedundant = true,\n        decay = 'exponential'\n    } = options\n\n    const bbox = turf.bbox({\n        type: \"FeatureCollection\", features: [\n            { type: \"Feature\", geometry: P, properties: {} },\n            { type: \"Feature\", geometry: Q, properties: {} }\n        ]\n    });\n\n    if (cleanRedundant) {\n        turf.cleanCoords(Q, { mutate: true });\n    }\n\n    const QPermutations = checkPermutations ? generateGeometryCoordinatePermutations(Q) : [Q];\n    const QWithPermutations = [Q, ...QPermutations]\n\n    let smallestDistance = Infinity;\n\n    while (QWithPermutations.length > 0) {\n        const permutedQ: Polygon = QWithPermutations.pop() as Polygon;\n        const distance = frechetDistance(P, permutedQ, { distanceMetric });\n\n        if (distance < smallestDistance) {\n            smallestDistance = distance;\n        }\n    }\n\n\n    const bboxDistance = distanceMetric([bbox[0], bbox[1]], [bbox[2], bbox[3]]);\n\n    return decay === 'linear' ? linearDecayFunction(smallestDistance, bboxDistance) : exponentialDecayFunction(smallestDistance, bboxDistance);\n}\n\n/**\n * Compute discrete Fréchet distance between two polygon Position sequences\n */\nexport function frechetDistance(\n    polygon1: Polygon | LineString,\n    polygon2: Polygon | LineString,\n    options: { distanceMetric: DistanceMetric } = { distanceMetric: haversineDistance }\n): number {\n    const { distanceMetric } = options;\n\n    const coordinatesOne = polygon1.type === 'Polygon' ? polygon1.coordinates[0] : polygon1.coordinates\n    const coordinatesTwo = polygon2.type === 'Polygon' ? polygon2.coordinates[0] : polygon2.coordinates\n\n    const numVerticesPolygon1 = coordinatesOne.length;\n    const numVerticesPolygon2 = coordinatesTwo.length;\n\n    const memoizationTable: number[][] = Array.from({ length: numVerticesPolygon1 }, () => Array(numVerticesPolygon2).fill(-1));\n\n    function calculateFrechetDistance(indexOne: number, indexTwo: number): number {\n        // Base cases\n        if (memoizationTable[indexOne][indexTwo] !== -1) {\n            return memoizationTable[indexOne][indexTwo];\n        }\n\n        if (indexOne === 0 && indexTwo === 0) {\n            memoizationTable[indexOne][indexTwo] = distanceMetric(\n                coordinatesOne[0],\n                coordinatesTwo[0]\n            );\n        } else if (indexOne > 0 && indexTwo === 0) {\n            memoizationTable[indexOne][indexTwo] = Math.max(\n                calculateFrechetDistance(indexOne - 1, 0),\n                distanceMetric(coordinatesOne[indexOne], coordinatesTwo[0])\n            );\n        } else if (indexOne === 0 && indexTwo > 0) {\n            memoizationTable[indexOne][indexTwo] = Math.max(\n                calculateFrechetDistance(0, indexTwo - 1),\n                distanceMetric(coordinatesOne[0], coordinatesTwo[indexTwo])\n            );\n        } else if (indexOne > 0 && indexTwo > 0) {\n            memoizationTable[indexOne][indexTwo] = Math.max(\n                Math.min(\n                    calculateFrechetDistance(indexOne - 1, indexTwo),\n                    calculateFrechetDistance(indexOne - 1, indexTwo - 1),\n                    calculateFrechetDistance(indexOne, indexTwo - 1)\n                ),\n                distanceMetric(coordinatesOne[indexOne], coordinatesTwo[indexTwo])\n            );\n        } else {\n            memoizationTable[indexOne][indexTwo] = Infinity;\n        }\n        return memoizationTable[indexOne][indexTwo];\n    }\n\n    const frechetDistanceValue = calculateFrechetDistance(numVerticesPolygon1 - 1, numVerticesPolygon2 - 1);\n\n    return frechetDistanceValue;\n}\n\nexport function exponentialDecayFunction(distance: number, maxDistance: number): number {\n    const alpha = -Math.log(0.005) / maxDistance;\n\n    // Exponential decay function to get similarity score\n    return Math.exp(-alpha * distance);\n}\n\nexport function linearDecayFunction(distance: number, maxDistance: number): number {\n    // Ensure distance is capped between 0 and maxDistance\n    const cappedDistance = Math.min(distance, maxDistance);\n\n    // Linear decay from 1 to 0 over the range [0, maxDistance]\n    return 1 - cappedDistance / maxDistance;\n}\n\nexport function generateGeometryCoordinatePermutations<T extends Polygon | LineString>(geometry: T): T[] {\n    // Check if the polygon has coordinates\n    if (!geometry.coordinates || geometry.coordinates.length === 0) {\n        return [];\n    }\n\n    const coordinates = geometry.type === 'Polygon' ? geometry.coordinates[0].slice(0, -1) : geometry.coordinates.slice(0) // Get the first ring of the polygon\n\n    const n = coordinates.length;\n\n    // Array to hold all permutations\n    const permutations: T[] = [];\n\n    // Generate all permutations by rotating the coordinates\n    for (let i = 0; i < n; i++) {\n\n        const permutedCoordinates = [...coordinates.slice(i), ...coordinates.slice(0, i)];\n\n        if (geometry.type === 'Polygon') {\n            permutedCoordinates.push(permutedCoordinates[0])\n        }\n\n        if (geometry.type === 'LineString' || i !== 0) {\n            // Create a new permutation starting from the i-th vertex\n            permutations.push({\n                type: geometry.type,\n                coordinates: geometry.type === 'Polygon' ? [permutedCoordinates] : permutedCoordinates // Wrap in an array for GeoJSON format\n            } as T);\n        }\n\n        // Create and add the reverse permutation\n        const reversedCoordinates = [...permutedCoordinates].reverse();\n        permutations.push({\n            type: geometry.type,\n            coordinates: geometry.type === 'Polygon' ? [reversedCoordinates] : reversedCoordinates // Wrap in an array for GeoJSON format\n        } as T);\n\n    }\n\n    return permutations;\n}"],"names":["haversineDistance","p1","p2","lat1","lat2","φ1","Math","PI","φ2","Δφ","Δλ","a","sin","cos","atan2","sqrt","frechetDistance","polygon1","polygon2","options","distanceMetric","coordinatesOne","type","coordinates","coordinatesTwo","numVerticesPolygon1","length","numVerticesPolygon2","memoizationTable","Array","from","fill","calculateFrechetDistance","indexOne","indexTwo","max","min","Infinity","exponentialDecayFunction","distance","maxDistance","alpha","log","exp","linearDecayFunction","generateGeometryCoordinatePermutations","geometry","slice","n","permutations","i","permutedCoordinates","concat","push","reversedCoordinates","reverse","P","Q","_options$distanceMetr","_options$checkPermuta","checkPermutations","_options$cleanRedunda","cleanRedundant","_options$decay","decay","bbox","turf","features","properties","cleanCoords","mutate","QPermutations","QWithPermutations","smallestDistance","pop","bboxDistance"],"mappings":"0TAKA,SAASA,EAAkBC,EAAcC,GACrC,IAAOC,EAAcF,EAAE,GAChBG,EAAcF,KAEfG,EAAKF,EAAOG,KAAKC,GAAK,IACtBC,EAAKJ,EAAOE,KAAKC,GAAK,IACtBE,GAAML,EAAOD,GAAQG,KAAKC,GAAK,IAC/BG,GALeR,EAAE,GADFD,EACrB,IAK2BK,KAAKC,GAAK,IAE/BI,EAAIL,KAAKM,IAAIH,EAAK,GAAKH,KAAKM,IAAIH,EAAK,GACvCH,KAAKO,IAAIR,GAAMC,KAAKO,IAAIL,GACxBF,KAAKM,IAAIF,EAAK,GAAKJ,KAAKM,IAAIF,EAAK,GAGrC,OAFU,EAAIJ,KAAKQ,MAAMR,KAAKS,KAAKJ,GAAIL,KAAKS,KAAK,EAAIJ,IAT3C,MAYd,CAiDgB,SAAAK,EACZC,EACAC,EACAC,QAAA,IAAAA,IAAAA,EAA8C,CAAEC,eAAgBpB,IAEhE,IAAQoB,EAAmBD,EAAnBC,eAEFC,EAAmC,YAAlBJ,EAASK,KAAqBL,EAASM,YAAY,GAAKN,EAASM,YAClFC,EAAmC,YAAlBN,EAASI,KAAqBJ,EAASK,YAAY,GAAKL,EAASK,YAElFE,EAAsBJ,EAAeK,OACrCC,EAAsBH,EAAeE,OAErCE,EAA+BC,MAAMC,KAAK,CAAEJ,OAAQD,GAAuB,WAAM,OAAAI,MAAMF,GAAqBI,MAAM,EAAE,GAwC1H,OAtCA,SAASC,EAAyBC,EAAkBC,GAEhD,OAA8C,IAA1CN,EAAiBK,GAAUC,KAK3BN,EAAiBK,GAAUC,GADd,IAAbD,GAA+B,IAAbC,EACqBd,EACnCC,EAAe,GACfG,EAAe,IAEZS,EAAW,GAAkB,IAAbC,EACgB5B,KAAK6B,IACxCH,EAAyBC,EAAW,EAAG,GACvCb,EAAeC,EAAeY,GAAWT,EAAe,KAExC,IAAbS,GAAkBC,EAAW,EACG5B,KAAK6B,IACxCH,EAAyB,EAAGE,EAAW,GACvCd,EAAeC,EAAe,GAAIG,EAAeU,KAE9CD,EAAW,GAAKC,EAAW,EACK5B,KAAK6B,IACxC7B,KAAK8B,IACDJ,EAAyBC,EAAW,EAAGC,GACvCF,EAAyBC,EAAW,EAAGC,EAAW,GAClDF,EAAyBC,EAAUC,EAAW,IAElDd,EAAeC,EAAeY,GAAWT,EAAeU,KAGrBG,UA5BhCT,EAAiBK,GAAUC,EA+B1C,CAE6BF,CAAyBP,EAAsB,EAAGE,EAAsB,EAGzG,CAEgB,SAAAW,EAAyBC,EAAkBC,GACvD,IAAMC,GAASnC,KAAKoC,IAAI,MAASF,EAGjC,OAAOlC,KAAKqC,KAAKF,EAAQF,EAC7B,CAEgB,SAAAK,EAAoBL,EAAkBC,GAKlD,OAAO,EAHgBlC,KAAK8B,IAAIG,EAAUC,GAGdA,CAChC,CAEM,SAAUK,EAAuEC,GAEnF,IAAKA,EAASvB,aAA+C,IAAhCuB,EAASvB,YAAYG,OAC9C,MAAO,GAWX,IARA,IAAMH,EAAgC,YAAlBuB,EAASxB,KAAqBwB,EAASvB,YAAY,GAAGwB,MAAM,GAAI,GAAKD,EAASvB,YAAYwB,MAAM,GAE9GC,EAAIzB,EAAYG,OAGhBuB,EAAoB,GAGjBC,EAAI,EAAGA,EAAIF,EAAGE,IAAK,CAExB,IAAMC,EAAmB,GAAAC,OAAO7B,EAAYwB,MAAMG,GAAO3B,EAAYwB,MAAM,EAAGG,IAExD,YAAlBJ,EAASxB,MACT6B,EAAoBE,KAAKF,EAAoB,IAG3B,eAAlBL,EAASxB,MAA+B,IAAN4B,GAElCD,EAAaI,KAAK,CACd/B,KAAMwB,EAASxB,KACfC,YAA+B,YAAlBuB,EAASxB,KAAqB,CAAC6B,GAAuBA,IAK3E,IAAMG,EAAsB,GAAAF,OAAID,GAAqBI,UACrDN,EAAaI,KAAK,CACd/B,KAAMwB,EAASxB,KACfC,YAA+B,YAAlBuB,EAASxB,KAAqB,CAACgC,GAAuBA,GAG3E,CAEA,OAAOL,CACX,gKA9JgB,SAAWO,EAAYC,EAAYtC,YAAAA,IAAAA,EAK/C,CAAA,GACA,IAKWuC,EAAPvC,EAJAC,eAAAA,OAAc,IAAAsC,EAAG1D,EAAiB0D,EAAAC,EAIlCxC,EAHAyC,kBAAAA,OAAoB,IAAHD,GAAOA,EAAAE,EAGxB1C,EAFA2C,eAAAA,OAAiB,IAAHD,GAAOA,EAAAE,EAErB5C,EADA6C,MAAAA,OAAK,IAAAD,EAAG,cAAaA,EAGnBE,EAAOC,EAAKD,KAAK,CACnB3C,KAAM,oBAAqB6C,SAAU,CACjC,CAAE7C,KAAM,UAAWwB,SAAUU,EAAGY,WAAY,CAAA,GAC5C,CAAE9C,KAAM,UAAWwB,SAAUW,EAAGW,WAAY,CAAI,MAIpDN,GACAI,EAAKG,YAAYZ,EAAG,CAAEa,QAAQ,IAQlC,IALA,IAAMC,EAAgBX,EAAoBf,EAAuCY,GAAK,CAACA,GACjFe,GAAqBf,GAACL,OAAKmB,GAE7BE,EAAmBpC,SAEhBmC,EAAkB9C,OAAS,GAAG,CACjC,IACMa,EAAWvB,EAAgBwC,EADNgB,EAAkBE,MACE,CAAEtD,eAAAA,IAE7CmB,EAAWkC,IACXA,EAAmBlC,EAE3B,CAGA,IAAMoC,EAAevD,EAAe,CAAC6C,EAAK,GAAIA,EAAK,IAAK,CAACA,EAAK,GAAIA,EAAK,KAEvE,MAAiB,WAAVD,EAAqBpB,EAAoB6B,EAAkBE,GAAgBrC,EAAyBmC,EAAkBE,EACjI"}