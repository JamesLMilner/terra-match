import*as t from"@turf/turf";function e(t,e){const[n,o]=t,[r,a]=e,i=n*Math.PI/180,c=r*Math.PI/180,s=(r-n)*Math.PI/180,h=(a-o)*Math.PI/180,l=Math.sin(s/2)*Math.sin(s/2)+Math.cos(i)*Math.cos(c)*Math.sin(h/2)*Math.sin(h/2);return 2*Math.atan2(Math.sqrt(l),Math.sqrt(1-l))*6371e3}function n(n,c,s={}){const{distanceMetric:h=e,checkPermutations:l=!0,cleanRedundant:p=!0,decay:u="exponential"}=s,y=t.bbox({type:"FeatureCollection",features:[{type:"Feature",geometry:n,properties:{}},{type:"Feature",geometry:c,properties:{}}]});p&&t.cleanCoords(c,{mutate:!0});const M=[c,...l?i(c):[c]];let d=Infinity;for(;M.length>0;){const t=o(n,M.pop(),{distanceMetric:h});t<d&&(d=t)}const f=h([y[0],y[1]],[y[2],y[3]]);return"linear"===u?a(d,f):r(d,f)}function o(t,n,o={distanceMetric:e}){const{distanceMetric:r}=o,a="Polygon"===t.type?t.coordinates[0]:t.coordinates,i="Polygon"===n.type?n.coordinates[0]:n.coordinates,c=a.length,s=i.length,h=Array.from({length:c},()=>Array(s).fill(-1));return function t(e,n){return-1!==h[e][n]||(h[e][n]=0===e&&0===n?r(a[0],i[0]):e>0&&0===n?Math.max(t(e-1,0),r(a[e],i[0])):0===e&&n>0?Math.max(t(0,n-1),r(a[0],i[n])):e>0&&n>0?Math.max(Math.min(t(e-1,n),t(e-1,n-1),t(e,n-1)),r(a[e],i[n])):Infinity),h[e][n]}(c-1,s-1)}function r(t,e){const n=-Math.log(.005)/e;return Math.exp(-n*t)}function a(t,e){return 1-Math.min(t,e)/e}function i(t){if(!t.coordinates||0===t.coordinates.length)return[];const e="Polygon"===t.type?t.coordinates[0].slice(0,-1):t.coordinates.slice(0),n=e.length,o=[];for(let r=0;r<n;r++){const n=[...e.slice(r),...e.slice(0,r)];"Polygon"===t.type&&n.push(n[0]),"LineString"!==t.type&&0===r||o.push({type:t.type,coordinates:"Polygon"===t.type?[n]:n});const a=[...n].reverse();o.push({type:t.type,coordinates:"Polygon"===t.type?[a]:a})}return o}export{r as exponentialDecayFunction,o as frechetDistance,i as generateGeometryCoordinatePermutations,a as linearDecayFunction,n as terraMatch};
//# sourceMappingURL=terra-match.modern.js.map
