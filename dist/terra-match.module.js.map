{"version":3,"file":"terra-match.module.js","sources":["../src/terra-match.ts"],"sourcesContent":["import { LineString, Polygon, Position } from 'geojson';\nimport * as turf from '@turf/turf';\n\ntype DistanceMetric = (p1: Position, p2: Position) => number\n\nfunction haversineDistance(p1: Position, p2: Position): number {\n    const [lat1, lon1] = p1;\n    const [lat2, lon2] = p2;\n    const R = 6371e3; // metres\n    const φ1 = lat1 * Math.PI / 180; // φ, λ in radians\n    const φ2 = lat2 * Math.PI / 180;\n    const Δφ = (lat2 - lat1) * Math.PI / 180;\n    const Δλ = (lon2 - lon1) * Math.PI / 180;\n\n    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +\n        Math.cos(φ1) * Math.cos(φ2) *\n        Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return R * c; // in metres\n}\n\nexport function terraMatch(P: Polygon, Q: Polygon, options: {\n    distanceMetric?: DistanceMetric,\n    checkPermutations?: boolean,\n    cleanRedundant?: boolean,\n    decay?: 'linear' | 'exponential'\n} = {}): number {\n    const {\n        distanceMetric = haversineDistance,\n        checkPermutations = true,\n        cleanRedundant = true,\n        decay = 'exponential'\n    } = options\n\n    const bbox = turf.bbox({\n        type: \"FeatureCollection\", features: [\n            { type: \"Feature\", geometry: P, properties: {} },\n            { type: \"Feature\", geometry: Q, properties: {} }\n        ]\n    });\n\n    if (cleanRedundant) {\n        turf.cleanCoords(Q, { mutate: true });\n    }\n\n    const QPermutations = checkPermutations ? generateGeometryCoordinatePermutations(Q) : [Q];\n    const QWithPermutations = [Q, ...QPermutations]\n\n    let smallestDistance = Infinity;\n\n    while (QWithPermutations.length > 0) {\n        const permutedQ: Polygon = QWithPermutations.pop() as Polygon;\n        const distance = frechetDistance(P, permutedQ, { distanceMetric });\n\n        if (distance < smallestDistance) {\n            smallestDistance = distance;\n        }\n    }\n\n\n    const bboxDistance = distanceMetric([bbox[0], bbox[1]], [bbox[2], bbox[3]]);\n\n    return decay === 'linear' ? linearDecayFunction(smallestDistance, bboxDistance) : exponentialDecayFunction(smallestDistance, bboxDistance);\n}\n\n/**\n * Compute discrete Fréchet distance between two polygon Position sequences\n */\nexport function frechetDistance(\n    polygon1: Polygon | LineString,\n    polygon2: Polygon | LineString,\n    options: { distanceMetric: DistanceMetric } = { distanceMetric: haversineDistance }\n): number {\n    const { distanceMetric } = options;\n\n    const coordinatesOne = polygon1.type === 'Polygon' ? polygon1.coordinates[0] : polygon1.coordinates\n    const coordinatesTwo = polygon2.type === 'Polygon' ? polygon2.coordinates[0] : polygon2.coordinates\n\n    const numVerticesPolygon1 = coordinatesOne.length;\n    const numVerticesPolygon2 = coordinatesTwo.length;\n\n    const memoizationTable: number[][] = Array.from({ length: numVerticesPolygon1 }, () => Array(numVerticesPolygon2).fill(-1));\n\n    function calculateFrechetDistance(indexOne: number, indexTwo: number): number {\n        // Base cases\n        if (memoizationTable[indexOne][indexTwo] !== -1) {\n            return memoizationTable[indexOne][indexTwo];\n        }\n\n        if (indexOne === 0 && indexTwo === 0) {\n            memoizationTable[indexOne][indexTwo] = distanceMetric(\n                coordinatesOne[0],\n                coordinatesTwo[0]\n            );\n        } else if (indexOne > 0 && indexTwo === 0) {\n            memoizationTable[indexOne][indexTwo] = Math.max(\n                calculateFrechetDistance(indexOne - 1, 0),\n                distanceMetric(coordinatesOne[indexOne], coordinatesTwo[0])\n            );\n        } else if (indexOne === 0 && indexTwo > 0) {\n            memoizationTable[indexOne][indexTwo] = Math.max(\n                calculateFrechetDistance(0, indexTwo - 1),\n                distanceMetric(coordinatesOne[0], coordinatesTwo[indexTwo])\n            );\n        } else if (indexOne > 0 && indexTwo > 0) {\n            memoizationTable[indexOne][indexTwo] = Math.max(\n                Math.min(\n                    calculateFrechetDistance(indexOne - 1, indexTwo),\n                    calculateFrechetDistance(indexOne - 1, indexTwo - 1),\n                    calculateFrechetDistance(indexOne, indexTwo - 1)\n                ),\n                distanceMetric(coordinatesOne[indexOne], coordinatesTwo[indexTwo])\n            );\n        } else {\n            memoizationTable[indexOne][indexTwo] = Infinity;\n        }\n        return memoizationTable[indexOne][indexTwo];\n    }\n\n    const frechetDistanceValue = calculateFrechetDistance(numVerticesPolygon1 - 1, numVerticesPolygon2 - 1);\n\n    return frechetDistanceValue;\n}\n\nexport function exponentialDecayFunction(distance: number, maxDistance: number): number {\n    const alpha = -Math.log(0.005) / maxDistance;\n\n    // Exponential decay function to get similarity score\n    return Math.exp(-alpha * distance);\n}\n\nexport function linearDecayFunction(distance: number, maxDistance: number): number {\n    // Ensure distance is capped between 0 and maxDistance\n    const cappedDistance = Math.min(distance, maxDistance);\n\n    // Linear decay from 1 to 0 over the range [0, maxDistance]\n    return 1 - cappedDistance / maxDistance;\n}\n\nexport function generateGeometryCoordinatePermutations<T extends Polygon | LineString>(geometry: T): T[] {\n    // Check if the polygon has coordinates\n    if (!geometry.coordinates || geometry.coordinates.length === 0) {\n        return [];\n    }\n\n    const coordinates = geometry.type === 'Polygon' ? geometry.coordinates[0].slice(0, -1) : geometry.coordinates.slice(0) // Get the first ring of the polygon\n\n    const n = coordinates.length;\n\n    // Array to hold all permutations\n    const permutations: T[] = [];\n\n    // Generate all permutations by rotating the coordinates\n    for (let i = 0; i < n; i++) {\n\n        const permutedCoordinates = [...coordinates.slice(i), ...coordinates.slice(0, i)];\n\n        if (geometry.type === 'Polygon') {\n            permutedCoordinates.push(permutedCoordinates[0])\n        }\n\n        if (geometry.type === 'LineString' || i !== 0) {\n            // Create a new permutation starting from the i-th vertex\n            permutations.push({\n                type: geometry.type,\n                coordinates: geometry.type === 'Polygon' ? [permutedCoordinates] : permutedCoordinates // Wrap in an array for GeoJSON format\n            } as T);\n        }\n\n        // Create and add the reverse permutation\n        const reversedCoordinates = [...permutedCoordinates].reverse();\n        permutations.push({\n            type: geometry.type,\n            coordinates: geometry.type === 'Polygon' ? [reversedCoordinates] : reversedCoordinates // Wrap in an array for GeoJSON format\n        } as T);\n\n    }\n\n    return permutations;\n}"],"names":["haversineDistance","p1","p2","lat1","lat2","φ1","Math","PI","φ2","Δφ","Δλ","a","sin","cos","atan2","sqrt","terraMatch","P","Q","options","_options$distanceMetr","distanceMetric","_options$checkPermuta","checkPermutations","_options$cleanRedunda","cleanRedundant","_options$decay","decay","bbox","turf","type","features","geometry","properties","cleanCoords","mutate","QPermutations","generateGeometryCoordinatePermutations","QWithPermutations","concat","smallestDistance","Infinity","length","distance","frechetDistance","pop","bboxDistance","linearDecayFunction","exponentialDecayFunction","polygon1","polygon2","coordinatesOne","coordinates","coordinatesTwo","numVerticesPolygon1","numVerticesPolygon2","memoizationTable","Array","from","fill","calculateFrechetDistance","indexOne","indexTwo","max","min","maxDistance","alpha","log","exp","slice","n","permutations","i","permutedCoordinates","push","reversedCoordinates","reverse"],"mappings":"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"}